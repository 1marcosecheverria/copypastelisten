<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CopyPasteListen Viewer</title>
  <meta name="color-scheme" content="dark light" />
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body {
      margin:0; background:#0b0b0b; color:#ddd;
      font:16px/1.6 -apple-system,system-ui,Segoe UI,Roboto,sans-serif;
    }
    header {
      position:sticky; top:0; z-index:10;
      display:flex; align-items:center; gap:10px;
      padding:12px 14px; background:#0b0b0b; border-bottom:1px solid #222;
    }
    header h1 { margin:0; font-size:16px; font-weight:700; }
    .meta { margin-left:auto; font-size:12px; color:#aaa }
    main { padding: 18px 14px 40px; max-width: 46rem; margin: 0 auto; }
    article h2 { margin: 0 0 10px; font-size: 20px; font-weight: 700; color:#fff; }
    article p { margin: 0 0 14px; white-space: pre-wrap; }
    nav.parts {
      position: sticky; bottom: 0; display:flex; gap:8px; align-items:center; justify-content:center;
      padding:10px; background:#0b0b0b; border-top:1px solid #222;
    }
    .btn { border:1px solid #333; background:#171717; color:#e6e6e6; padding:8px 10px; border-radius:10px; font-size:13px; text-decoration:none; }
    .btn:active { transform: translateY(1px); opacity:.9 }
    .pill { padding:6px 10px; border-radius:20px; border:1px solid #333; }
  </style>
  <!-- Optional compression support; page works without it for plain payloads -->
  <script defer src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
</head>
<body>
  <header>
    <h1>CopyPasteListen</h1>
    <span class="meta" id="meta">0 chars</span>
  </header>

  <main>
    <article aria-label="Article">
      <h2 id="title"></h2>
      <div id="content"></div>
    </article>

    <nav class="parts" id="parts" hidden>
      <a class="btn" id="prev" href="#">◀︎ Prev</a>
      <span class="pill" id="where">Part 1/1</span>
      <a class="btn" id="next" href="#">Next ▶︎</a>
    </nav>
  </main>

  <script>
  (function () {
    // Query params control behavior:
    //   ?chunk=0|1 (default 0)   -> whether to split into parts
    //   ?p=1                     -> which part to show (1-based)
    //   ?chunkSize=12000         -> max chars per part (when chunk=1)
    const qs = new URLSearchParams(location.search);
    const chunkEnabled = (qs.get('chunk') || '0') === '1';
    const partParam    = Math.max(1, parseInt(qs.get('p') || '1', 10) || 1);
    const maxChars     = Math.max(2000, parseInt(qs.get('chunkSize') || '12000', 10) || 12000);

    const titleEl = document.getElementById('title');
    const contentEl = document.getElementById('content');
    const metaEl = document.getElementById('meta');
    const partsNav = document.getElementById('parts');
    const whereEl = document.getElementById('where');
    const prevEl = document.getElementById('prev');
    const nextEl = document.getElementById('next');

    function decodePayload(payload) {
      try {
        if (payload.startsWith('lz:') && window.LZString) {
          return LZString.decompressFromEncodedURIComponent(payload.slice(3)) || '';
        }
        return decodeURIComponent(payload);
      } catch { return payload; }
    }

    function parseHash() {
      const hash = location.hash.startsWith('#') ? location.hash.slice(1) : '';
      if (!hash) return { title:'', text:'' };
      if (hash.includes('=') && hash.includes('&')) {
        const p = new URLSearchParams(hash);
        const title = decodeURIComponent(p.get('title') || '');
        const raw = p.get('text') || '';
        return { title, text: decodePayload(raw) };
      }
      return { title:'', text: decodePayload(hash) };
    }

    function splitIntoParagraphs(text) {
      return text.replace(/\r\n/g,'\n').split(/\n\s*\n+/g).map(s=>s.trim()).filter(Boolean);
    }

    function chunkParagraphs(paras) {
      if (!chunkEnabled) return [paras];
      const out = []; let cur=[]; let len=0;
      for (const p of paras) {
        const add = p.length + 2;
        if (len + add > maxChars && cur.length) { out.push(cur); cur=[]; len=0; }
        cur.push(p); len += add;
      }
      if (cur.length) out.push(cur);
      return out.length ? out : [paras];
    }

    function render() {
      const { title, text } = parseHash();
      document.title = (title || 'CopyPasteListen') + ' — Viewer';

      const paras = splitIntoParagraphs(text);
      const parts = chunkParagraphs(paras);
      const total = parts.length;
      const idx = Math.min(Math.max(1, partParam), total) - 1;

      titleEl.textContent = title || '';
      contentEl.innerHTML = '';
      for (const p of parts[idx]) {
        const el = document.createElement('p');
        el.textContent = p;
        contentEl.appendChild(el);
      }

      metaEl.textContent = `${(text||'').length} chars • ${paras.length} paragraphs${chunkEnabled ? ' • chunked' : ''}`;
      whereEl.textContent = `Part ${idx+1}/${total}`;
      partsNav.hidden = total <= 1; // no nav if single part

      // Nav links preserve the same hash (payload) and toggle ?p=
      const base = location.pathname + `?chunk=${chunkEnabled?1:0}&chunkSize=${maxChars}`;
      const mk = (n)=> `${base}&p=${n}${location.hash}`;
      prevEl.href = idx>0 ? mk(idx) : '#';
      nextEl.href = idx+1<total ? mk(idx+2) : '#';
      prevEl.onclick = (e)=>{ if(idx===0) return; e.preventDefault(); location.href = mk(idx); };
      nextEl.onclick = (e)=>{ if(idx+1>=total) return; e.preventDefault(); location.href = mk(idx+2); };

      window.scrollTo(0,0); // helps Siri/Reader start at the top
    }

    render();
    window.addEventListener('hashchange', ()=> location.reload());
  })();
  </script>
</body>
</html>
